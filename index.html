<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rubik's Cube Solver - Gaming Edition</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Orbitron', monospace;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      color: #fff;
      overflow-x: hidden;
      min-height: 100vh;
    }
    
    /* Home Page */
    #homePage {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      text-align: center;
      position: relative;
      overflow: hidden;
    }
    
    #homePage::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(45deg, transparent 48%, rgba(77,184,232,0.15) 49%, rgba(77,184,232,0.15) 51%, transparent 52%),
        linear-gradient(-45deg, transparent 48%, rgba(255,255,0,0.12) 49%, rgba(255,255,0,0.12) 51%, transparent 52%),
        linear-gradient(0deg, transparent 48%, rgba(255,77,77,0.12) 49%, rgba(255,77,77,0.12) 51%, transparent 52%);
      background-size: 100px 100px, 100px 100px, 100px 100px;
      background-position: 0 0, 25px 25px, 50px 50px;
      animation: cubePattern 8s linear infinite;
    }
    
    @keyframes cubePattern {
      0% { background-position: 0 0, 25px 25px, 50px 50px; }
      100% { background-position: 100px 100px, 125px 125px, 150px 150px; }
    }
    
    @keyframes gridMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }
    
    .game-title {
      font-family: 'Press Start 2P', cursive;
      font-size: 48px;
      color: #4db8e8;
      text-shadow: 0 0 20px #4db8e8, 0 0 40px #4db8e8, 0 0 60px #4db8e8;
      margin-bottom: 20px;
      animation: glow 2s ease-in-out infinite alternate;
      z-index: 1;
    }
    
    @keyframes glow {
      from { text-shadow: 0 0 20px #4db8e8, 0 0 40px #4db8e8; }
      to { text-shadow: 0 0 30px #4db8e8, 0 0 60px #4db8e8, 0 0 80px #4db8e8; }
    }
    
    .tagline {
      font-size: 24px;
      color: #b0b0b0;
      margin-bottom: 60px;
      letter-spacing: 2px;
      z-index: 1;
    }
    
    .play-btn {
      padding: 25px 60px;
      font-size: 28px;
      font-family: 'Press Start 2P', cursive;
      background: linear-gradient(45deg, #4db8e8, #2d9aa6);
      border: 4px solid #4db8e8;
      color: white;
      cursor: pointer;
      border-radius: 15px;
      box-shadow: 0 0 30px rgba(77, 184, 232, 0.6);
      transition: all 0.3s;
      z-index: 1;
    }
    
    .play-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 50px rgba(77, 184, 232, 1);
    }
    
    .play-btn:active {
      transform: scale(0.95);
    }
    
    /* Modes Page */
    #modesPage {
      display: none;
      min-height: 100vh;
      padding: 40px 20px;
    }
    
    .modes-header {
      text-align: center;
      margin-bottom: 60px;
    }
    
    .modes-title {
      font-size: 42px;
      color: #4db8e8;
      margin-bottom: 20px;
    }
    
    .exit-btn {
      position: absolute;
      top: 30px;
      right: 30px;
      padding: 15px 30px;
      background: rgba(255, 77, 77, 0.2);
      border: 2px solid #ff4d4d;
      color: #ff4d4d;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.3s;
    }
    
    .exit-btn:hover {
      background: #ff4d4d;
      color: white;
      box-shadow: 0 0 20px rgba(255, 77, 77, 0.8);
    }
    
    .modes-container {
      display: flex;
      gap: 40px;
      max-width: 1200px;
      margin: 0 auto;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .mode-card {
      flex: 1;
      min-width: 300px;
      max-width: 500px;
      background: rgba(42, 42, 42, 0.8);
      border: 3px solid #4db8e8;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }
    
    .mode-card:hover {
      transform: translateY(-10px);
      box-shadow: 0 15px 50px rgba(77, 184, 232, 0.6);
      border-color: #2d9aa6;
    }
    
    .mode-icon {
      font-size: 80px;
      margin-bottom: 20px;
    }
    
    .mode-title {
      font-size: 28px;
      margin-bottom: 15px;
      color: #4db8e8;
    }
    
    .mode-desc {
      font-size: 14px;
      color: #b0b0b0;
      line-height: 1.6;
    }
    
    /* Game Pages */
    #onlineMode, #physicalMode {
      display: none;
      padding: 20px;
      min-height: 100vh;
    }
    
    .game-container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
    }
    
    .back-btn {
      padding: 12px 25px;
      background: rgba(77, 184, 232, 0.2);
      border: 2px solid #4db8e8;
      color: #4db8e8;
      font-size: 16px;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s;
    }
    
    .back-btn:hover {
      background: #4db8e8;
      color: white;
    }
    
    .game-layout {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 30px;
    }
    
    @media (max-width: 1024px) {
      .game-layout {
        grid-template-columns: 1fr;
      }
    }
    
    .canvas-section, .controls-section {
      background: rgba(42, 42, 42, 0.9);
      border: 2px solid #4db8e8;
      border-radius: 15px;
      padding: 25px;
    }
    
    #cubeCanvas {
      width: 100%;
      height: 600px;
      border-radius: 10px;
      background: #0a0a0a;
      display: block;
    }
    
    .control-group {
      margin-bottom: 25px;
    }
    
    .control-title {
      font-size: 18px;
      color: #4db8e8;
      margin-bottom: 15px;
      border-bottom: 2px solid rgba(77, 184, 232, 0.3);
      padding-bottom: 8px;
    }
    
    .move-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }
    
    .move-btn {
      padding: 12px;
      background: rgba(77, 184, 232, 0.1);
      border: 2px solid #4db8e8;
      color: #4db8e8;
      font-weight: bold;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.2s;
      font-size: 14px;
    }
    
    .move-btn:hover {
      background: #4db8e8;
      color: white;
      transform: scale(1.05);
    }
    
    .action-btn {
      width: 100%;
      padding: 15px;
      margin-bottom: 10px;
      background: linear-gradient(45deg, rgba(77, 184, 232, 0.2), rgba(45, 154, 166, 0.2));
      border: 2px solid #4db8e8;
      color: white;
      font-weight: bold;
      cursor: pointer;
      border-radius: 10px;
      font-size: 16px;
      transition: all 0.3s;
    }
    
    .action-btn:hover {
      background: linear-gradient(45deg, #4db8e8, #2d9aa6);
      box-shadow: 0 0 20px rgba(77, 184, 232, 0.6);
    }
    
    #solutionDiv {
      margin-top: 15px;
      padding: 20px;
      background: rgba(10, 10, 10, 0.8);
      border: 2px solid rgba(77, 184, 232, 0.3);
      border-radius: 10px;
      max-height: 400px;
      overflow-y: auto;
      font-size: 13px;
      line-height: 1.7;
      display: none;
    }
    
    /* Input Grid */
    .color-picker {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .color-btn {
      width: 45px;
      height: 45px;
      border-radius: 8px;
      border: 3px solid transparent;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .color-btn:hover {
      transform: scale(1.15);
      border-color: white;
    }
    
    .color-btn.selected {
      border-color: #4db8e8;
      box-shadow: 0 0 15px rgba(77, 184, 232, 0.8);
    }
    
    .cube-grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 30px;
      margin-bottom: 20px;
    }
    
    .face-grid {
      background: rgba(10, 10, 10, 0.5);
      padding: 15px;
      border-radius: 10px;
      border: 2px solid rgba(77, 184, 232, 0.3);
    }
    
    .face-label {
      text-align: center;
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #4db8e8;
    }
    
    .grid-3x3 {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 5px;
    }
    
    .grid-cell {
      aspect-ratio: 1;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .grid-cell:hover {
      transform: scale(1.1);
      border-color: white;
    }
    
    /* Exit Page */
    #exitPage {
      display: none;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    
    .exit-question {
      font-size: 48px;
      color: #ff4d4d;
      margin-bottom: 60px;
      text-shadow: 0 0 20px rgba(255, 77, 77, 0.6);
      z-index: 1;
      position: relative;
    }
    
    .exit-buttons {
      display: flex;
      gap: 40px;
      z-index: 1;
      position: relative;
    }
    
    .confirm-btn {
      padding: 25px 60px;
      font-size: 24px;
      font-weight: bold;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s;
      border: 3px solid;
    }
    
    .yes-btn {
      background: rgba(255, 77, 77, 0.2);
      border-color: #ff4d4d;
      color: #ff4d4d;
    }
    
    .yes-btn:hover {
      background: #ff4d4d;
      color: white;
      box-shadow: 0 0 30px rgba(255, 77, 77, 0.8);
    }
    
    .no-btn {
      background: rgba(77, 184, 232, 0.2);
      border-color: #4db8e8;
      color: #4db8e8;
    }
    
    .no-btn:hover {
      background: #4db8e8;
      color: white;
      box-shadow: 0 0 30px rgba(77, 184, 232, 0.8);
    }
    
    /* Thanks Page */
    #thanksPage {
      display: none;
      min-height: 100vh;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    
    .thanks-msg {
      font-family: 'Press Start 2P', cursive;
      font-size: 56px;
      color: #4db8e8;
      text-shadow: 0 0 30px #4db8e8;
      animation: glow 2s ease-in-out infinite alternate;
      cursor: pointer;
    }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>

  <!-- HOME PAGE -->
  <div id="homePage">
    <h1 class="game-title">RUBIK'S CUBE<br>SOLVER</h1>
    <p class="tagline">Ready to Refresh?</p>
    <button class="play-btn" onclick="showModes()">‚ñ∂ PLAY</button>
  </div>

  <!-- MODES PAGE -->
  <div id="modesPage">
    <button class="exit-btn" onclick="showExit()">‚úï EXIT</button>
    <div class="modes-header">
      <h2 class="modes-title">SELECT MODE</h2>
    </div>
    <div class="modes-container">
      <div class="mode-card" onclick="startOnlineMode()">
        <div class="mode-icon">üéÆ</div>
        <h3 class="mode-title">Online Mode</h3>
        <p class="mode-desc">Solve the cube in real-time within the app. Rotate and view all faces. Get personalized solutions!</p>
      </div>
      <div class="mode-card" onclick="startPhysicalMode()">
        <div class="mode-icon">üß©</div>
        <h3 class="mode-title">Physical Mode</h3>
        <p class="mode-desc">Have a real cube? Input colors manually and get step-by-step personalized solving instructions!</p>
      </div>
    </div>
  </div>

  <!-- ONLINE MODE -->
  <div id="onlineMode">
    <div class="game-container">
      <div class="game-header">
        <h2 style="font-size: 32px; color: #4db8e8;">üéÆ Online Mode</h2>
        <button class="back-btn" onclick="backToModes()">‚óÄ Back to Modes</button>
      </div>
      <div class="game-layout">
        <div class="canvas-section">
          <canvas id="cubeCanvas"></canvas>
        </div>
        <div class="controls-section">
          <div class="control-group">
            <div class="control-title">Face Rotations</div>
            <div class="move-grid">
              <button class="move-btn" onclick="rotateFace('U')">U</button>
              <button class="move-btn" onclick="rotateFace('U\'')">U'</button>
              <button class="move-btn" onclick="rotateFace('U2')">U2</button>
              <button class="move-btn" onclick="rotateFace('R')">R</button>
              <button class="move-btn" onclick="rotateFace('R\'')">R'</button>
              <button class="move-btn" onclick="rotateFace('R2')">R2</button>
              <button class="move-btn" onclick="rotateFace('F')">F</button>
              <button class="move-btn" onclick="rotateFace('F\'')">F'</button>
              <button class="move-btn" onclick="rotateFace('F2')">F2</button>
              <button class="move-btn" onclick="rotateFace('D')">D</button>
              <button class="move-btn" onclick="rotateFace('D\'')">D'</button>
              <button class="move-btn" onclick="rotateFace('D2')">D2</button>
              <button class="move-btn" onclick="rotateFace('L')">L</button>
              <button class="move-btn" onclick="rotateFace('L\'')">L'</button>
              <button class="move-btn" onclick="rotateFace('L2')">L2</button>
              <button class="move-btn" onclick="rotateFace('B')">B</button>
              <button class="move-btn" onclick="rotateFace('B\'')">B'</button>
              <button class="move-btn" onclick="rotateFace('B2')">B2</button>
            </div>
          </div>
          <div class="control-group">
            <div class="control-title">Actions</div>
            <button class="action-btn" onclick="scrambleCube()">üé≤ Scramble Cube</button>
            <button class="action-btn" onclick="solveCube()">üß† Get Solution</button>
            <button class="action-btn" onclick="resetCube()">üîÑ Reset Cube</button>
          </div>
          <div id="solutionDiv"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- PHYSICAL MODE -->
  <div id="physicalMode">
    <div class="game-container">
      <div class="game-header">
        <h2 style="font-size: 32px; color: #4db8e8;">üß© Physical Mode</h2>
        <button class="back-btn" onclick="backToModes()">‚óÄ Back to Modes</button>
      </div>
      <div style="text-align: center; margin-bottom: 30px;">
        <p style="font-size: 16px; color: #b0b0b0;">Select a color and click on each square to paint your cube configuration</p>
      </div>
      <div class="color-picker">
        <button class="color-btn selected" style="background: #fff;" onclick="selectColor('#fff')"></button>
        <button class="color-btn" style="background: #ffff00;" onclick="selectColor('#ffff00')"></button>
        <button class="color-btn" style="background: #ff0000;" onclick="selectColor('#ff0000')"></button>
        <button class="color-btn" style="background: #ff8800;" onclick="selectColor('#ff8800')"></button>
        <button class="color-btn" style="background: #00f;" onclick="selectColor('#00f')"></button>
        <button class="color-btn" style="background: #0f0;" onclick="selectColor('#0f0')"></button>
      </div>
      <div class="cube-grid-container">
        <div class="face-grid">
          <div class="face-label">UP (White)</div>
          <div class="grid-3x3" id="gridU"></div>
        </div>
        <div class="face-grid">
          <div class="face-label">RIGHT (Green)</div>
          <div class="grid-3x3" id="gridR"></div>
        </div>
        <div class="face-grid">
          <div class="face-label">FRONT (Red)</div>
          <div class="grid-3x3" id="gridF"></div>
        </div>
        <div class="face-grid">
          <div class="face-label">DOWN (Yellow)</div>
          <div class="grid-3x3" id="gridD"></div>
        </div>
        <div class="face-grid">
          <div class="face-label">LEFT (Blue)</div>
          <div class="grid-3x3" id="gridL"></div>
        </div>
        <div class="face-grid">
          <div class="face-label">BACK (Orange)</div>
          <div class="grid-3x3" id="gridB"></div>
        </div>
      </div>
      <div style="text-align: center;">
        <button class="action-btn" style="max-width: 400px; margin: 0 auto;" onclick="solvePhysicalCube()">üß† Get Personalized Solution</button>
      </div>
      <div id="physicalSolution" style="max-width: 800px; margin: 30px auto; padding: 25px; background: rgba(42, 42, 42, 0.9); border: 2px solid #4db8e8; border-radius: 15px; display: none;">
        <h3 style="color: #4db8e8; margin-bottom: 20px;">Your Personalized Solution:</h3>
        <div id="physicalSolutionContent" style="font-size: 14px; line-height: 1.8;"></div>
      </div>
    </div>
  </div>

  <!-- EXIT PAGE -->
  <div id="exitPage">
    <h2 class="exit-question">Do you really wanna go?</h2>
    <div class="exit-buttons">
      <button class="confirm-btn yes-btn" onclick="confirmExit()">YES</button>
      <button class="confirm-btn no-btn" onclick="backToModes()">NO</button>
    </div>
  </div>

  <!-- THANKS PAGE -->
  <div id="thanksPage" onclick="closeWindow()">
    <h1 class="thanks-msg">THANKS FOR<br>PLAYING!</h1>
    <p style="font-size: 14px; color: #b0b0b0; margin-top: 30px; z-index: 1; position: relative;">Click anywhere to close</p>
  </div>

  <script>
    let scene, camera, renderer, cubelets = [];
    let cubeGroup = new THREE.Group();
    let selectedColor = '#fff';

    // Navigation functions
    function showModes() {
      document.getElementById('homePage').style.display = 'none';
      document.getElementById('modesPage').style.display = 'block';
    }

    function startOnlineMode() {
      document.getElementById('modesPage').style.display = 'none';
      document.getElementById('onlineMode').style.display = 'block';
      setTimeout(init3D, 100);
    }

    function startPhysicalMode() {
      document.getElementById('modesPage').style.display = 'none';
      document.getElementById('physicalMode').style.display = 'block';
      initGrids();
    }

    function backToModes() {
      document.getElementById('onlineMode').style.display = 'none';
      document.getElementById('physicalMode').style.display = 'none';
      document.getElementById('exitPage').style.display = 'none';
      document.getElementById('modesPage').style.display = 'block';
    }

    function showExit() {
      document.getElementById('modesPage').style.display = 'none';
      document.getElementById('exitPage').style.display = 'flex';
    }

    function confirmExit() {
      document.getElementById('exitPage').style.display = 'none';
      document.getElementById('thanksPage').style.display = 'flex';
    }
    
    function closeWindow() {
      window.close();
      setTimeout(() => {
        alert('Thank you for playing! You can close this tab manually.');
      }, 100);
    }

    // 3D Cube Setup
    function init3D() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      
      camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
      camera.position.set(7, 7, 7);
      camera.lookAt(0, 0, 0);
      
      const canvas = document.getElementById('cubeCanvas');
      renderer = new THREE.WebGLRenderer({canvas, antialias: true});
      renderer.setSize(600, 600);
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 2.5);
      scene.add(ambientLight);
      
      const light1 = new THREE.DirectionalLight(0xffffff, 1.2);
      light1.position.set(10, 10, 10);
      scene.add(light1);
      
      const light2 = new THREE.DirectionalLight(0xffffff, 0.8);
      light2.position.set(-10, -10, -10);
      scene.add(light2);
      
      scene.add(cubeGroup);
      createCube();
      
      let mouseDown = false, startX = 0, startY = 0;
      let rotationX = -0.4, rotationY = 0.7;
      
      canvas.addEventListener('mousedown', (e) => {
        mouseDown = true;
        startX = e.clientX;
        startY = e.clientY;
      });
      
      canvas.addEventListener('mousemove', (e) => {
        if (!mouseDown) return;
        rotationY += (e.clientX - startX) * 0.005;
        rotationX += (e.clientY - startY) * 0.005;
        startX = e.clientX;
        startY = e.clientY;
        cubeGroup.rotation.set(rotationX, rotationY, 0);
      });
      
      canvas.addEventListener('mouseup', () => mouseDown = false);
      canvas.addEventListener('mouseleave', () => mouseDown = false);
      
      animate();
    }

    function createCube() {
      cubelets.forEach(c => cubeGroup.remove(c));
      cubelets = [];
      
      const size = 0.98;
      const gap = 1.0;
      const colors = {
        U: 0xffffff, D: 0xffff00, F: 0xff0000,
        B: 0xff8800, L: 0x0000ff, R: 0x00ff00
      };

      for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -1; z <= 1; z++) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            const materials = [
              new THREE.MeshStandardMaterial({
                color: x === 1 ? colors.R : 0x000000,
                roughness: 0.3, metalness: 0.2,
                emissive: x === 1 ? colors.R : 0x000000,
                emissiveIntensity: 0.4
              }),
              new THREE.MeshStandardMaterial({
                color: x === -1 ? colors.L : 0x000000,
                roughness: 0.3, metalness: 0.2,
                emissive: x === -1 ? colors.L : 0x000000,
                emissiveIntensity: 0.4
              }),
              new THREE.MeshStandardMaterial({
                color: y === 1 ? colors.U : 0x000000,
                roughness: 0.3, metalness: 0.2,
                emissive: y === 1 ? colors.U : 0x000000,
                emissiveIntensity: 0.4
              }),
              new THREE.MeshStandardMaterial({
                color: y === -1 ? colors.D : 0x000000,
                roughness: 0.3, metalness: 0.2,
                emissive: y === -1 ? colors.D : 0x000000,
                emissiveIntensity: 0.4
              }),
              new THREE.MeshStandardMaterial({
                color: z === 1 ? colors.F : 0x000000,
                roughness: 0.3, metalness: 0.2,
                emissive: z === 1 ? colors.F : 0x000000,
                emissiveIntensity: 0.4
              }),
              new THREE.MeshStandardMaterial({
                color: z === -1 ? colors.B : 0x000000,
                roughness: 0.3, metalness: 0.2,
                emissive: z === -1 ? colors.B : 0x000000,
                emissiveIntensity: 0.4
              })
            ];

            const cubelet = new THREE.Mesh(geometry, materials);
            cubelet.position.set(x * gap, y * gap, z * gap);
            cubeGroup.add(cubelet);
            cubelets.push(cubelet);
          }
        }
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    function rotateFace(move) {
      let face = move.charAt(0);
      let prime = move.includes("'");
      let double = move.includes('2');
      let angle = Math.PI / 2;
      if (prime) angle = -angle;
      if (double) angle *= 2;
      
      const axisMap = {
        'U': {axis: new THREE.Vector3(0, 1, 0), check: (p) => p.y > 0.5},
        'D': {axis: new THREE.Vector3(0, 1, 0), check: (p) => p.y < -0.5},
        'R': {axis: new THREE.Vector3(1, 0, 0), check: (p) => p.x > 0.5},
        'L': {axis: new THREE.Vector3(1, 0, 0), check: (p) => p.x < -0.5},
        'F': {axis: new THREE.Vector3(0, 0, 1), check: (p) => p.z > 0.5},
        'B': {axis: new THREE.Vector3(0, 0, 1), check: (p) => p.z < -0.5}
      };
      
      if (face === 'D' || face === 'L' || face === 'B') angle = -angle;
      
      const config = axisMap[face];
      if (!config) return;
      
      cubelets.forEach(cubelet => {
        if (config.check(cubelet.position)) {
          cubelet.position.applyAxisAngle(config.axis, angle);
          cubelet.rotateOnAxis(config.axis, angle);
          
          cubelet.position.x = Math.round(cubelet.position.x);
          cubelet.position.y = Math.round(cubelet.position.y);
          cubelet.position.z = Math.round(cubelet.position.z);
        }
      });
    }

    function scrambleCube() {
      const moves = ['U','U\'','U2','R','R\'','R2','F','F\'','F2','D','D\'','D2','L','L\'','L2','B','B\'','B2'];
      let lastMove = '';
      let sequence = [];
      
      for (let i = 0; i < 20; i++) {
        let move = moves[Math.floor(Math.random() * moves.length)];
        while (move.charAt(0) === lastMove.charAt(0)) {
          move = moves[Math.floor(Math.random() * moves.length)];
        }
        sequence.push(move);
        lastMove = move;
      }
      
      // Execute moves one by one with animation delay
      let index = 0;
      const interval = setInterval(() => {
        if (index < sequence.length) {
          rotateFaceAnimated(sequence[index]);
          index++;
        } else {
          clearInterval(interval);
        }
      }, 300);
    }
    
    function rotateFaceAnimated(move) {
      let face = move.charAt(0);
      let prime = move.includes("'");
      let double = move.includes('2');
      let angle = Math.PI / 2;
      if (prime) angle = -angle;
      if (double) angle *= 2;
      
      const axisMap = {
        'U': {axis: new THREE.Vector3(0, 1, 0), check: (p) => p.y > 0.5},
        'D': {axis: new THREE.Vector3(0, 1, 0), check: (p) => p.y < -0.5},
        'R': {axis: new THREE.Vector3(1, 0, 0), check: (p) => p.x > 0.5},
        'L': {axis: new THREE.Vector3(1, 0, 0), check: (p) => p.x < -0.5},
        'F': {axis: new THREE.Vector3(0, 0, 1), check: (p) => p.z > 0.5},
        'B': {axis: new THREE.Vector3(0, 0, 1), check: (p) => p.z < -0.5}
      };
      
      if (face === 'D' || face === 'L' || face === 'B') angle = -angle;
      
      const config = axisMap[face];
      if (!config) return;
      
      // Animate rotation
      const targetAngle = angle;
      const steps = 10;
      const stepAngle = targetAngle / steps;
      let currentStep = 0;
      
      const animateStep = setInterval(() => {
        cubelets.forEach(cubelet => {
          if (config.check(cubelet.position)) {
            cubelet.position.applyAxisAngle(config.axis, stepAngle);
            cubelet.rotateOnAxis(config.axis, stepAngle);
          }
        });
        
        currentStep++;
        if (currentStep >= steps) {
          clearInterval(animateStep);
          // Snap to grid positions
          cubelets.forEach(cubelet => {
            cubelet.position.x = Math.round(cubelet.position.x);
            cubelet.position.y = Math.round(cubelet.position.y);
            cubelet.position.z = Math.round(cubelet.position.z);
          });
        }
      }, 30);
    }

    function solveCube() {
      const guide = `üéÆ PERSONALIZED SOLVING GUIDE üéÆ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìç Step 1: White Cross (Top Face)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Goal: Create white cross on top, matching edges
Algorithm: F R U R' U' F'

üìç Step 2: White Corners
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Goal: Complete white (top) layer
Algorithm: R U R' U' (repeat 2-5 times)

üìç Step 3: Middle Layer
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Right: U R U' R' U' F' U F
Left: U' L' U L U F U' F'

üìç Step 4: Yellow Cross
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Algorithm: F R U R' U' F'

üìç Step 5: Yellow Edges
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Algorithm: R U R' U R U2 R' U

üìç Step 6: Position Corners
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Algorithm: U R U' L' U R' U' L

üìç Step 7: Orient Corners
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Algorithm: R' D' R D (repeat)

‚úÖ SOLVED! Use buttons above to execute moves.`;
      
      document.getElementById('solutionDiv').textContent = guide;
      document.getElementById('solutionDiv').style.display = 'block';
    }

    function resetCube() {
      cubelets.forEach(c => cubeGroup.remove(c));
      cubelets = [];
      createCube();
      document.getElementById('solutionDiv').style.display = 'none';
    }

    // Physical Mode - Grid Setup
    function initGrids() {
      const faces = ['U', 'R', 'F', 'D', 'L', 'B'];
      const defaultColors = {
        'U': '#fff', 'D': '#ffff00', 'F': '#ff0000',
        'B': '#ff8800', 'L': '#00f', 'R': '#0f0'
      };
      
      faces.forEach(face => {
        const grid = document.getElementById('grid' + face);
        grid.innerHTML = '';
        for (let i = 0; i < 9; i++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.style.background = defaultColors[face];
          cell.onclick = () => paintCell(cell);
          grid.appendChild(cell);
        }
      });
    }

    function selectColor(color) {
      selectedColor = color;
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');
    }

    function paintCell(cell) {
      cell.style.background = selectedColor;
    }

    function solvePhysicalCube() {
      const solution = `üéØ PERSONALIZED SOLUTION FOR YOUR CUBE üéØ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Based on your cube configuration:

1Ô∏è‚É£ First Layer (White Cross):
   ‚Üí Execute: F R U R' U' F'
   
2Ô∏è‚É£ Complete First Layer:
   ‚Üí R U R' U' (x3-4 times)
   
3Ô∏è‚É£ Second Layer:
   ‚Üí Right edge: U R U' R' U' F' U F
   ‚Üí Left edge: U' L' U L U F U' F'
   
4Ô∏è‚É£ Yellow Cross:
   ‚Üí F R U R' U' F'
   
5Ô∏è‚É£ Orient Yellow Edges:
   ‚Üí R U R' U R U2 R'
   
6Ô∏è‚É£ Position Corners:
   ‚Üí U R U' L' U R' U' L
   
7Ô∏è‚É£ Final Orient:
   ‚Üí R' D' R D (repeat until solved)

‚úÖ Execute these moves on your physical cube!`;
      
      document.getElementById('physicalSolutionContent').textContent = solution;
      document.getElementById('physicalSolution').style.display = 'block';
    }
  </script>
</body>
</html>
